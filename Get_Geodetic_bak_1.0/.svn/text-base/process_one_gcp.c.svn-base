/******************************************************************************
NAME:           process_one_gcp

PURPOSE:        Update the normal equation of the least-square problem for 
                correction solution by adding one Ground Control Point.

RETURNS:        SUCCESS or ERROR
*******************************************************************************
                       Property of the U.S. Government
                           USGS EROS Data Center
******************************************************************************/
#include "ias_structures.h"
#include "ias_const.h"
#include "ias_logging.h"
#include "ias_geo.h"
#include "gcp_struct.h"
#include "correct_los_model.h"

int process_one_gcp
(
    const IAS_VECTOR *satpos,/* I: Satellite position vector, Earth-fixed
                                  (meters) */
    const IAS_VECTOR *satvec,/* I: Satellite velocity vector, in Earth-fixed
                                  (meters/second) */
    const IAS_VECTOR *satatt,/* I: Satellite attitude (radians) */
    const IAS_VECTOR *gcppos,/* I: GCP position vector, Earth-fixed (meters) */
    int outflag,            /* I: GCP outlier flag GOOD/OUTLIER/INVALID_POINT */
    PARAM_FLAG param_flag,  /* I: Parameterization flag, valued "att_orb",
                                  "eph_yaw", "both", or "weight" */
    int est_time_flag,      /* I: Time rate estimation flag, valued 1 or 0 */
    double diff_time,       /* I: Time difference from the reference time to
                                  the sensor time for the GCP (seconds) */
    double delta,           /* I: Across-track angle of the pixel point
                                  (radians) */
    double psi,             /* I: Along-track angle of the pixel point
                                  (radian) */
    double radius,          /* I: Radius of the Earth (meters) */
    double height,          /* I: Height of satellite (meters) */
    NORMAL_STRUCT *normal,  /* I/O: Structure of normal equation information.
                                    Updated by adding the current GCP */
    double apd[],           /* O: Alpha partial derivatives for current GCP */
    double bpd[],           /* O: Beta partial derivatives for current GCP */
    double *alpha,          /* O: Differences in across-track angle
                                  (micro radian) */
    double *beta            /* O: Differences in along-track angle
                                  (micro radian) */
)
{
    double Tef2oo[3][3];        /* Transformation matrix from EF to Orbit
                                   system */
    double delta1, psi1;        /* Line-of-sight angles to the GCP (radians) */
    double *norm_mx[NPARMS];    /* Array of pointers for normal matrix */
    double H1[NPARMS];          /* Partial coefficients for alpha */
    double H2[NPARMS];          /* Partial coefficients for beta */
    int i;                      /* Looping variable */
    int status;

    /* Calculate the transformation matrix from EF to Orbit system */
    status = ias_geo_compute_earth2orbit_transform(satpos, satvec, Tef2oo);
    if (status != SUCCESS)
    {
        IAS_LOG_ERROR("Calculating the EF to orbit transformation matrix");
        return ERROR;
    }

    /* Calculate the line-of-sight angles for GCP. */
    calc_line_of_sight(gcppos, satpos, Tef2oo, &delta1, &psi1);

    /************************************************************************
     * The look vectors here sould be in the Orbit reference system. If the  * 
     * line of sight angle for the pixel Pi is from the forward model        * 
     * (in the spacecraft-fixed system), then it should be transformed into  * 
     * the Orbit reference system (through matrix A(roll, pitch, yaw))       * 
     * first before the observable alpha and beta can be formed              * 
     ************************************************************************/

    /* Compute the observable alpha and beta */
    /* Multiply by 1.0e6 to convert to micro radians */
    *alpha = 1.0e6 * (delta1 - delta);
    *beta = 1.0e6 * (psi1 - psi);

    /* Skip the augmentation of the normal eqns and rhs arrays if the
       point is not a good point */
    if (outflag == GOOD_POINT)
    {
        /* Relate the observable to correction parameters */
        status = setup_partial_coefficients(param_flag, est_time_flag, delta,
                diff_time, radius, height, satatt, H1, H2);
        if (status != SUCCESS)
        {
            IAS_LOG_ERROR("Setting up the partial coefficients to relate "
                "the observable to correction parameters");
            return ERROR;
        }
        /* Save the partials to pass back for later outlier analysis */
        for (i = 0; i < NPARMS; i++)
        {
            apd[i] = H1[i];
            bpd[i] = H2[i];
        }

        /* Update the weighted square summation of observation */
        normal->obs_vwv += ((*alpha) * (*alpha) * (normal->obs_wgt[0]));
        normal->obs_vwv += ((*beta) * (*beta) * (normal->obs_wgt[1]));
        normal->obs_num += 1.0;
        normal->obs_num += 1.0;

        for (i = 0; i < NPARMS; i++)
            norm_mx[i] = normal->obs_mx[i];

        /* Accumulate the normal equation for alpha */
        accum_normal_equation(H1, *alpha, NPARMS, normal->obs_wgt[0], norm_mx,
                normal->obs_rgt);

        /* Accumulate the normal equation for beta */
        accum_normal_equation(H2, *beta, NPARMS, normal->obs_wgt[1], norm_mx,
                normal->obs_rgt);
    }

    return SUCCESS;
}
